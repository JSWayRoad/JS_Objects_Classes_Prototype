##  prototype
https://learn.javascript.ru/prototypes  
https://github.com/radomir-radionov/closures_and_objects#9  

Прототип используется только для чтения свойств.  
Операции записи/удаления работают напрямую с объектом.  
Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.

В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null.  
Мы можем использовать obj.__proto__ для доступа к нему (исторически обусловленный геттер/сеттер, есть другие способы, которые скоро будут рассмотрены).  
Объект, на который ссылается [[Prototype]], называется «прототипом».  
Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.  
Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).  
Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.  
Цикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта.


Rabbit.prototype = animal;  
Установка Rabbit.prototype = animal буквально говорит интерпретатору следующее: "При создании объекта через new Rabbit() запиши ему animal в [[Prototype]]".  
У каждой функции по умолчанию уже есть свойство "prototype".  
По умолчанию "prototype" – объект с единственным свойством constructor, которое ссылается на функцию-конструктор.  
Свойство F.prototype (не путать с [[Prototype]]) устанавливает[[Prototype]] для новых объектов при вызове new F().  
По умолчанию все функции имеют F.prototype = { constructor: F }, поэтому мы можем получить конструктор объекта через свойство "constructor".  

### Встроенные прототипы

Но краткая нотация obj = {} – это то же самое, что и obj = new Object(), где Object – встроенная функция-конструктор для объектов с собственным свойством prototype, которое ссылается на огромный объект с методом toString и другими.  

Примитивы Самое сложное происходит со строками, числами и булевыми значениями.  
Как мы помним, они не объекты. Но если мы попытаемся получить доступ к их свойствам, то тогда будет создан временный объект-обёртка с использованием встроенных конструкторов String, Number и Boolean, который предоставит методы и после этого исчезнет.  
Полифил – это термин, который означает эмуляцию метода, который существует в спецификации JavaScript, но ещё не поддерживается текущим движком JavaScript.  

