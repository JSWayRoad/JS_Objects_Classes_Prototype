# JS_Objects_Classes  

https://learn.javascript.ru/object-basics

**Объекты для хранения именованных коллекций(свойств).(индекс/значение)**  
**Свойство** – это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»), а значение может быть чем угодно.
```
let user = new Object(); // синтаксис "конструктор объекта" 
//  литеральная нотацией.
let user = {};  // синтаксис "литерал объекта"
delete user.age; 
//для удаления свойств
```
**Массивы для хранения упорядоченных коллекций.(ключ/значение)**

Объект — это набор свойств, и каждое свойство состоит из имени и значения.  
Объекты же используются для хранения коллекций различных значений и более сложных сущностей.  
Объект может быть создан с помощью фигурных скобок {…} с необязательным списком свойств.  
Свойство – это пара «ключ: значение», где ключ – это строка (также называемая «именем свойства»),  
а значение может быть чем угодно.

### Как узнать есть ли свойство в объекте?**  
Метод hasOwnProperty() возвращает логическое значение, указывающее, содержит ли объект указанное свойство  
Каждый объект, произошедший от Object, наследует метод hasOwnProperty

### Как перебрать ключи объекта?**  
Цикл for in помогает получать на каждой итерации ключ объекта, используя который, мы получаем доступ к значению объекта.  
Метод Object.keys() принимает объект в качестве аргумента и возвращает массив с заданными ключами объекта.  
Используя данный метод, мы получаем доступ только к значениям объекта.  
Метод Object.entries() принимает объект в качестве аргумента и возвращает массив с массивами,  
которые являются парами [key, value] данного объекта.

### Расскажите и приведите пример копирования объекта по ссылке?  

Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке».  
Примитивные типы: строки, числа, логические значения – присваиваются и копируются «по значению».  
Переменная хранит не сам объект, а его «адрес в памяти», другими словами «ссылку» на него.  
Сам объект хранится где-то в памяти. А в переменной user лежит «ссылка» на эту область памяти.  
Когда переменная объекта копируется – копируется ссылка, сам же объект не дублируется.

 Сравнение по ссылке  
 Операторы равенства == и строгого равенства === для объектов работают одинаково.  
 Два объекта равны только в том случае, если это один и тот же объект.
  
  Объекты присваиваются и копируются по ссылке. Другими словами, переменная хранит не «значение объекта»,  
  а «ссылку» (адрес в памяти) на это значение. Поэтому копирование такой переменной или передача её в  
  качестве аргумента функции приводит к копированию этой ссылки, а не самого объекта.  
  Все операции с использованием скопированных ссылок (например, добавление или удаление свойств) выполняются с одним и тем же объектом.

Для «простого клонирования» объекта можно использовать Object.assign. Необходимо помнить,  
что Object.assign не делает глубокое клонирования объекта. Если внутри копируемого объекта есть свойство,  
значение которого не является примитивом, оно будет передано по ссылке. Для создания «настоящей копии»  
(полного клона объекта) можно воспользоваться методом из сторонней JavaScript-библиотеки _.cloneDeep(obj).

### В каком случае два объекта равны?  
В том случае, если у них одинаковая ссылка.

### Расскажите о отличиях == и === в контексте сравнения объектов?**  
Операторы равенства == и строгого равенства === для объектов работают одинаково.  
Два объекта равны только в том случае, если это один и тот же объект

### Что делает for...in?**  
Для перебора всех свойств из объекта используется цикл по свойствам for..in.  
Эта синтаксическая конструкция отличается от рассмотренного ранее цикла for(;;).
```
for..in
Синтаксис:
 for (key in obj) {
  /* ... делать что-то с obj[key] ... */
 }
```
// При этом for..in последовательно переберёт свойства объекта obj, имя каждого свойства будет записано в key и вызвано тело цикла.

**Мы можем использовать квадратные скобки в литеральной нотации для создания вычисляемого свойства.**  
**Проверка существования свойства, оператор «in»**  
**Одним из фундаментальных отличий объектов от примитивных типов данных является то, что они хранятся и копируются «по ссылке».**  
Примитивные типы: строки, числа, логические значения – присваиваются и копируются «по значению».
```
let user = { name: 'Иван' };
let admin = user;
admin.name = 'Петя'; // изменено по ссылке из переменной "admin"
alert(user.name); // 'Петя', изменения видны по ссылке из переменной "user"
```


Массивы явл разновидностью объектов с расширенным поведением.  
У них имеются итераторы, свои методы и свойства  
**Объекты  представляют собой коллекцию пар ключ/значение  
Массив представляет собой упорядоченную коллекцию данных, индекс/ элемент**

**Объекты позволяют нам создавать одну сущность, которая хранит элементы данных по ключам, а массивы – хранить упорядоченные коллекции данных.**


### Копирование объектов 

Use the spread (...) syntax
Use the Object.assign() method
Use the JSON.stringify() and JSON.parse() methods  
Копирование  циклом  
рекурсия


### new это(прототипы)  

https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/new  
https://learn.javascript.ru/constructor-new  
https://puzzleweb.ru/javascript/7_new.php  

Когда функция вызывается как new User(...), происходит следующее:  
Создаётся новый пустой объект, и он присваивается this.  
Выполняется код функции. Обычно он модифицирует this, добавляет туда новые свойства.  
Возвращается значение this.  

целью конструкторов – удобное повторное создание однотипных объектов.  

Обычно конструкторы ничего не возвращают явно. Их задача – записать все необходимое в this, который в итоге станет результатом.  
Но если return всё же есть, то применяется простое правило:  
При вызове return с объектом, будет возвращён объект, а не this.  
При вызове return с примитивным значением, примитивное значение будет отброшено.  
Другими словами, return с объектом возвращает объект, в любом другом случае конструктор вернёт this.


Когда функ вызывается после оператора new(такие вызовы наз вызовами-конструкторами),вып след действия:

создаётся новый объект  
производится связывние сконструированного объекта с [[Prototype]]  
сконструированный объект назначается в качестве связывания this для этого вызова функции  
если функция не возврщ свой альтернатиынй объект, вызов функции авт возвращает сконструированный объект.


## 17 Map & Set  

https://learn.javascript.ru/map-set  

**Map** – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.  
В отличие от объектов, ключи не были приведены к строкам. Можно использовать любые типы данных для ключей.  
**Map может использовать объекты в качестве ключей.**

Объект *Set** – это особый вид коллекции: «множество» значений (без ключей), где каждое значение может появляться только один раз.  
поменять порядок элементов или получить элемент напрямую по его номеру нельзя.



## class(конструктор в классе и super)  

https://learn.javascript.ru/classes  
класс – это расширяемый шаблон кода для создания объектов, который устанавливает в них начальные значения (свойства) и реализацию поведения (методы).

## Деструктуризация  
https://learn.javascript.ru/destructuring-assignment  

**Деструктурирующее присваивание** – это специальный синтаксис, который позволяет нам «распаковать» массивы или объекты в кучу переменных,  
так как иногда они более удобны.  
```
// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"]

// деструктурирующее присваивание
// записывает firstName=arr[0], surname=arr[1]
let [firstName, surname] = arr;

alert(firstName); // Ilya
alert(surname);  // Kantor  
```  

Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.  
Полный синтаксис для объекта:
```
let {prop : varName = default, ...rest} = object
```
Свойства, которые не были упомянуты, копируются в объект rest.  
Полный синтаксис для массива:
```
let [item1 = default, item2, ...rest] = array
```
Первый элемент отправляется в item1; второй отправляется в item2, все остальные элементы попадают в массив rest.  
Можно извлекать данные из вложенных объектов и массивов, для этого левая сторона должна иметь ту же структуру, что и правая.

### Операторы Spread и Rest

https://learn.javascript.ru/rest-parameters-spread-operator
